消息队列使用场景
1. 异步处理
可以更快地返回结果
减少等待，实现步骤之间的并发，提升系统总体的性能

2. 流量控制
使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的

3. 服务解耦

RabbitMQ 缺点
1. RabbitMQ 对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降
2. RabbitMQ 的性能相较于其他消息队列而言很差。依据硬件配置的不同，大概每秒钟只能处理几万到十几万条消息
3. RabbitMQ 使用的编程语言非常小众

RocketMQ 的性能比 RabbitMQ 要高一个数量级，每秒钟大概能处理几十万条消息

Kafka 的性能，尤其是异步收发的性能非常好。

但是 Kafka 的异步批量的设计导致它的同步收发消息的响应时延比较高，因为当客户端发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景


RabbitMQ 的消息模型
是少数依然坚持使用队列模型的产品。在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中


消息队列是如何实现分布式事务
1. 在消息队列上开启一个事务
2. 向消息服务器发送一个半消息（半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的）
3. 半消息发送成功后，执行本地事务
4. 根据本地事务的执行结果决定提交或者回滚事务消息

如果提交事务消息时失败
Kafka 直接抛出异常，我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿


发送消息时，正确处理返回值或者捕获异常，就可以保证生产阶段的消息不会丢失
