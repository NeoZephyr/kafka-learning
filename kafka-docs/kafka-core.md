## 副本机制
副本机制有以下优势：
1. 提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，增加了整体可用性以及数据持久性
2. 提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量
3. 改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时

对于 Apache Kafka 而言，目前只能享受到副本机制带来的第 1 个好处，也就是提供数据冗余实现高可用性和高持久性

### 副本角色
Kafka 采用基于领导者（Leader-based）的副本机制

1. 在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个领导者副本，其余的副本自动称为追随者副本

2. 在 Kafka 中，追随者副本不对外提供服务。这就是说，所有的读写请求都必须 发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步

3. 当领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。当原 Leader 副本重启回来后，只能作为追随者副本加入到集群中

这种副本机制有以下优势：
1. 当生产者 向 Kafka 成功写入消息后，消费者马上就能读取刚才生产的消息。如果允许追随者副本对外提供服务，由于副本同步是异步的，因此有可能出现追随者副本还没有从领导者副本那里拉取到最新的消息，从而使得客户端看不到最新写入的消息

2. 方便实现单调读，如果允许追随者副本提供读服务，可能会看到这样的现象：第一次消费时看到的最新消息在第二次消费时不见了

### In-sync Replicas（ISR）
Kafka 引入 ISR 副本集合，ISR 中的副本都是与 Leader 同步的副本。相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的。Leader 副本天然就在 ISR 中

Kafka 判断 Follower 是否与 Leader 同步的标准就是 Broker 端参数 `replica.lag.time.max.ms`。这个参数的表示 Follower 副本能够落后 Leader 副本的最长时间间隔，默认值是 10 秒。因此，只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息

如果 Follower 副本与 Leader 副本不同步，就会被踢出 ISR。当该副本追上 Leader 时，又能够重新被加回 ISR

### Unclean 领导者选举
ISR 可能出现为空的现象，Kafka 需要重新选举一个新的 Leader。此时如果选择非同步副本作为新 Leader，就可能出现数据的丢失。Broker 端参数 `unclean.leader.election.enable` 控制是否允许 Unclean 领导者选举

开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性

建议你不要开启 Unclean 领导者选举


## 请求处理
### 处理流程
1. Acceptor 线程采用轮询的方式将入站请求公平地发到所有网络线程中
2. 网络线程池，Broker 端参数 `num.network.threads` 用于调整网络线程池的线程数。默认值是 3，表示每台 Broker 启动时会创建 3 个网络线程处理客户端发送的请求
3. 网络线程拿到请求后，将其放入到一个共享请求队列中
4. IO 线程池，负责从共享请求队列中取出请求并处理。如果是 PRODUCE 生产请求，则将消息写入到底层的磁盘日志中；如果是 FETCH 请求，则从磁盘或页缓存中读取消息。Broker 端参数 `num.io.threads` 控制 IO 线程池中的线程数。默认值是 8，表示每台 Broker 启动后自动创建 8 个 IO 线程处理请求。如果机器上 CPU 资源非常充裕，可以调大该参数，允许更多的并发请求被同时处理
5. IO 线程处理完请求后，将生成的响应发送到响应队列中，由对应的网络线程负责将响应返还给客户端

### Purgatory 组件
用来缓存延时请求，即那些一时未满足条件不能立刻处理的请求。比如设置了 acks=all 的 PRODUCE 请求，该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中

### 请求类型
在 Kafka 内部，除了客户端发送的 PRODUCE 请求和 FETCH 请求之外，还有很多执行其他操作的请求类型，比如负责更新 Leader 副本、Follower 副本以及 ISR 集合的 LeaderAndIsr 请求，负责勒令副本下线的 StopReplica 请求等。与 PRODUCE 和 FETCH 请求相比，这些请求有个明显的不同：它们不是数据类的请求，而是控制类的请求。Kafka 社区把 PRODUCE 和 FETCH 这类请求称为数据类请求，把 LeaderAndIsr、StopReplica 这类请求称为控制类请求

社区于 2.3 版本正式实现了数据类请求和控制类请求的分离。Kafka Broker 启动后，会在后台分别两套创建网络线程池和 IO 线程池，它们分别处理数据类请求和控制类请求




